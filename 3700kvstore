#!/usr/bin/env python3

import argparse, socket, time, json, select, struct, sys, math, os, random

BROADCAST = "FFFF"

FOLLOWER = "follower"
CANDIDATE = "candidate"
LEADER = "leader"

class Replica:
    def __init__(self, port, id, others):
        self.port = port
        self.id = id
        self.others = others

        self.num_puts = 0

        self.state = FOLLOWER
        self.leader = "FFFF"

        self.current_term = 0
        self.voted = False
        self.votes = 0
        self.log = [{"term": 0}]

        self.commit_index = 0
        self.last_applied = 0

        self.next_index = {}
        self.match_index = {}

        self.kvstore = {}
        self.unconfirmed_put = {}
        self.quorum = set()

        self.unprocessed_msgs = []

        self.client_buffer = []
        self.peer_buffer = []

        self.latest_update = time.time()
        self.timeout = self.new_timeout()

        self.latest_rep_update = {}

        self.socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        self.socket.bind(('localhost', 0))

        print("Replica %s starting up" % self.id, flush=True)
        hello = { "src": self.id, "dst": BROADCAST, "leader": BROADCAST, "type": "hello" }
        self.send(hello)
        print("Sent hello message: %s" % hello, flush=True)

    def new_timeout(self):
        return random.uniform(0.75,1.0)

    def send(self, message):
        self.socket.sendto(json.dumps(message).encode('utf-8'), ('localhost', self.port))

    def receive_all(self):
        while True:
            msg = self.recv_msg()
            if msg:
                print("Received message '%s'" % (msg,), flush=True)
                self.unprocessed_msgs.append(msg)
            else:
                return

    def recv_msg(self):
        ready_for_reading = select.select([self.socket], [], [], 0.000001)[0]
        if self.socket in ready_for_reading:
            raw_msg = self.socket.recv(65535)
            if raw_msg:
                return json.loads(raw_msg.decode('utf-8'))
        return None

    def init_msg(self, dst, type):
        response = {
            "src": self.id,
            "dst": dst,
            "leader": self.leader,
            "type": type
        }
        return response

    def take_lead(self):
        self.state = LEADER
        self.leader = self.id
        self.votes = 0

        curr_time = time.time()

        for rep in self.others:
            self.next_index[rep] = len(self.log)
            self.match_index[rep] = 0
            self.latest_rep_update[rep] = curr_time

        append_entry = self.init_msg(BROADCAST, "append_entry")
        append_entry["term"] = self.current_term
        append_entry["prev_log_index"] = 0
        append_entry["prev_log_term"] = 0
        append_entry["entries"] = []
        append_entry["leader_commit"] = self.commit_index
        self.peer_buffer.append(append_entry)

    def follow(self, leader, curr_time, term):
        self.state = FOLLOWER
        self.leader = leader
        self.current_term = term
        self.next_index = {}
        self.match_index = {}
        self.voted = False
        self.votes = 0
        self.timeout = self.new_timeout()
        self.latest_update = curr_time
        self.latest_rep_update = {}


    def follower_func(self):

        backlog = []
        curr_time = time.time()

        while self.unprocessed_msgs:
            msg = self.unprocessed_msgs.pop(0)

            if msg["type"] in ["get", "put"]:
                if self.leader != "FFFF":
                    response = self.init_msg(msg["src"], "redirect")
                    response["MID"] = msg["MID"]
                    self.client_buffer.append(response)
                else:
                    backlog.append(msg)

            elif msg["type"] == "request_vote":
                if msg["term"] >= self.current_term:
                    if not self.voted:
                        # self.leader = "FFFF"
                        self.current_term = msg["term"]
                        response = self.init_msg(msg["src"], "vote")
                        response["term"] = self.current_term

                        self.voted = True
                        self.latest_update = curr_time
                        self.timeout = self.new_timeout()

                        self.peer_buffer.append(response)
                    # already voted, send a vote denial
                    else:
                        pass
                # vote request is for outdated term, send vote denial
                else:
                    pass


            elif msg["type"] == "append_entry":
                # check for consistency
                if (msg["term"] >= self.current_term and
                    msg["prev_log_index"] < len(self.log) and
                    msg["prev_log_term"] == self.log[msg["prev_log_index"]]["term"]):
                    # update follower information accordingly
                    self.leader = msg["leader"]
                    self.current_term = msg["term"]
                    self.voted = False
                    self.latest_update = curr_time

                    if msg["entries"]:
                         # remove any entries not found in leader's log + add new entries
                        self.log = self.log[:msg["prev_log_index"]+1] + msg["entries"]
                        response = self.init_msg(msg["src"], "append_entry_response")
                        response["term"] = self.current_term
                        response["success"] = True
                        response["next_index"] = len(self.log)
                        response["put_MID"] = msg["put_MID"]
                        self.peer_buffer.append(response)

                    if msg["leader_commit"] > self.commit_index:
                        self.commit_index = min(msg["leader_commit"], len(self.log) - 1) # , len(self.log) - 1

                        while self.commit_index > self.last_applied:
                            self.last_applied += 1
                            last_applied = self.log[self.last_applied]
                            self.kvstore.update({last_applied["key"]: last_applied["value"]})

                # if the new leader has an outdated term, reject the append entry and
                # inform it of the proper leader
                else:
                    response = self.init_msg(msg["src"], "append_entry_response")
                    response["term"] = self.current_term
                    response["success"] = False
                    response["next_index"] = self.commit_index
                    self.peer_buffer.append(response)

        self.unprocessed_msgs = backlog

    def leader_func(self):
        backlog = []
        curr_time = time.time()

        while self.unprocessed_msgs:
            msg = self.unprocessed_msgs.pop(0)

            if msg["type"] == "put":
                # if there's no put that has yet to be committed:
                if not self.unconfirmed_put:
                    self.log.append({"client": msg["src"], "term": self.current_term,
                                     "MID": msg["MID"], "key": msg["key"], 
                                     "value": msg["value"]}) # , "index": len(self.log) + 1
                    self.unconfirmed_put = msg
                    self.quorum.add(self.id)
                    self.num_puts += 1
                else:
                    backlog.append(msg)


            elif msg["type"] == "get":
                val = self.kvstore.get(msg["key"], "")

                response = self.init_msg(msg["src"], "ok")
                response["value"] = val
                response["MID"] = msg["MID"]
                self.client_buffer.append(response)

            elif msg["type"] == "append_entry":
                if msg["term"] > self.current_term:
                    # response = self.init_msg(self.unconfirmed_put["src"], "redirect")
                    # response["MID"] = self.unconfirmed_put["MID"]
                    # self.send(response)

                    self.follow(msg["leader"], curr_time, msg["term"])
                    # return self.follower_func()
                # else, make sure everyone knows we are still the leader
                # NOTE: maybe change later depending on efficiency
                else:
                    append_entry = self.init_msg(msg["src"], "append_entry_response")
                    append_entry["term"] = self.current_term
                    append_entry["success"] = False
                    self.peer_buffer.append(response)


            elif msg["type"] == "request_vote":
                # if our current term is outdated, step down as leader
                if msg["term"] > self.current_term:
                    pass
                # otherwise, reject the vote request
                else:
                    pass

            elif msg["type"] == "append_entry_response":
                if msg["success"]:
                    self.next_index[msg["src"]] = min(msg["next_index"], len(self.log))
                    self.match_index[msg["src"]] = self.next_index[msg["src"]] - 1

                    if self.unconfirmed_put and msg["put_MID"] == self.unconfirmed_put["MID"]:
                        self.quorum.add(msg["src"])

                        if len(self.quorum) > len(self.others) / 2:
                            self.commit_index = len(self.log) - 1
                            self.unconfirmed_put.clear()
                            self.quorum.clear()
                else:
                    if self.current_term < msg["term"]:
                        # response = self.init_msg(self.unconfirmed_put["src"], "redirect")
                        # response["MID"] = self.unconfirmed_put["MID"]
                        # self.send(response)

                        self.follow(msg["leader"], curr_time, msg["term"])
                        # return self.follower_func()


            for n in range(self.commit_index + 1, len(self.log)):
                if (len(list(filter(lambda i: self.match_index[i] >= n, self.others)))
                    > len(self.match_index) / 2):
                    if self.log[n]["term"] == self.current_term:
                        self.commit_index = n
                else:
                    break

            while self.commit_index > self.last_applied:
                self.last_applied += 1
                last_app = self.log[self.last_applied]
                self.kvstore.update({last_app["key"]: last_app["value"]})

                response = self.init_msg(last_app["client"], "ok")
                response["MID"] = last_app["MID"]
                self.client_buffer.append(response)
        
        self.unprocessed_msgs = backlog

    def candidate_func(self):
        curr_time = time.time()

        while self.unprocessed_msgs:
            msg = self.unprocessed_msgs.pop(0)

            if msg["type"] == "append_entry":
                # if our term is outdated, back out of election and follow
                if msg["term"] >= self.current_term:
                    self.follow(msg["leader"], curr_time, msg["term"])
                    return self.follower_func()
                # reject the append entry, respond with candidacy?
                else:
                    pass

            elif msg["type"] == "vote":
                if msg["term"] == self.current_term:
                    self.votes += 1

                    if self.votes > len(self.others) / 2:
                        self.take_lead()
                # back out of election
                elif msg["term"] > self.current_term:
                    pass

            # depending on current_term, either reject vote or step down and vote
            elif msg["type"] == "request_vote":
                pass

    def start_election(self):
        self.state = CANDIDATE
        self.current_term += 1
        self.votes += 1

        self.latest_update = time.time()

        request_vote = self.init_msg("FFFF", "request_vote")
        request_vote["term"] = self.current_term
        request_vote["last_log_index"] = len(self.log) - 1
        request_vote["last_log_term"] = self.log[-1]["term"]

        self.peer_buffer.append(request_vote)

    def append_entry(self, rep, entries):
        append_entry = self.init_msg(rep, "append_entry")
        append_entry["term"] = self.current_term
        append_entry["prev_log_index"] = self.next_index[rep] - 1
        append_entry["prev_log_term"] = self.log[self.next_index[rep] - 1]["term"]
        append_entry["entries"] = entries
        append_entry["leader_commit"] = self.commit_index
        append_entry["num_puts"] = self.num_puts
        if self.unconfirmed_put:
            append_entry["put_MID"] = self.unconfirmed_put["MID"]
        return append_entry

    def run(self):
        while True:
            while self.client_buffer:
                self.send(self.client_buffer.pop(0))

            while self.peer_buffer:
                self.send(self.peer_buffer.pop(0))


            if self.state is LEADER:
                for rep in self.others:
                    if (len(self.log) - 1 >= self.next_index[rep]) and (time.time() > self.latest_rep_update[rep] + 0.0025):
                        self.send(self.append_entry(rep, self.log[self.next_index[rep]:]))
                        self.latest_rep_update[rep] = time.time()
                    elif time.time() > self.latest_rep_update[rep] + 0.5:
                        self.send(self.append_entry(rep, []))
                        self.latest_rep_update[rep] = time.time()

            self.receive_all()

            if self.state == FOLLOWER:
                self.follower_func()
            if self.state == LEADER:
                self.leader_func()
            if self.state == CANDIDATE:
                self.candidate_func()

            if self.state is not LEADER and time.time() > self.latest_update + self.timeout:
                self.start_election()

if __name__ == "__main__":
    parser = argparse.ArgumentParser(description='run a key-value store')
    parser.add_argument('port', type=int, help="Port number to communicate")
    parser.add_argument('id', type=str, help="ID of this replica")
    parser.add_argument('others', metavar='others', type=str, nargs='+', help="IDs of other replicas")
    args = parser.parse_args()
    replica = Replica(args.port, args.id, args.others)
    replica.run()
