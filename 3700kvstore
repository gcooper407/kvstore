#!/usr/bin/env python3

import argparse, socket, time, json, select, random

BROADCAST = "FFFF"

FOLLOWER = "follower"
CANDIDATE = "candidate"
LEADER = "leader"

class Replica:
    def __init__(self, port, id, others):
        # TODO briefly explain fields (based on groups)
        self.port = port
        self.id = id
        self.others = others

        self.num_puts = 0

        self.state = FOLLOWER
        self.leader = "FFFF"

        self.current_term = 0
        self.voted = False
        self.votes = 0
        self.log = [{"term": 0}]

        self.commit_index = 0
        self.last_applied = 0

        self.next_index = {}
        self.match_index = {}

        self.kvstore = {}
        self.staged_put = {}
        self.quorum = set()

        self.unprocessed_msgs = []

        self.client_reponse_queue = []
        self.peer_reponse_queue = []

        self.latest_update = time.time()
        self.timeout = self.new_timeout()

        self.latest_rep_update = {}

        self.socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        self.socket.bind(('localhost', 0))

        print("Replica %s starting up" % self.id, flush=True)
        hello = { "src": self.id, "dst": BROADCAST, "leader": BROADCAST, "type": "hello" }
        self.send(hello)
        print("Sent hello message: %s" % hello, flush=True)

    def new_timeout(self):
        return random.uniform(0.5,0.65)

    def send(self, message):
        msg = json.dumps(message).encode('utf-8')
        self.socket.sendto(msg, ('localhost', self.port))

    def receive_all(self):
        while True:
            msg = self.recv_msg()
            if msg:
                print("Received message '%s'" % (msg,), flush=True)
                self.unprocessed_msgs.append(msg)
            else:
                return

    def recv_msg(self):
        ready_for_reading = select.select([self.socket], [], [], 0.0001)[0]
        if self.socket in ready_for_reading:
            raw_msg = self.socket.recv(65535)
            if raw_msg:
                return json.loads(raw_msg.decode('utf-8'))
        return None

    def init_msg(self, dst, type):
        response = {
            "src": self.id,
            "dst": dst,
            "leader": self.leader,
            "type": type
        }
        return response

    def take_lead(self):
        # TODO briefly explain how a replica takes the lead
        self.state = LEADER
        self.leader = self.id
        self.votes = 0

        curr_time = time.time()

        for rep in self.others:
            self.next_index[rep] = len(self.log)
            self.match_index[rep] = 0
            self.latest_rep_update[rep] = {"sent": curr_time, "timeout": 0.0025}

        append_entry = self.init_msg(BROADCAST, "append_entry")
        append_entry["term"] = self.current_term
        append_entry["prev_log_index"] = 0
        append_entry["prev_log_term"] = 0
        append_entry["entries"] = []
        append_entry["leader_commit"] = self.commit_index
        self.peer_reponse_queue.append(append_entry)

    def follow(self, leader, curr_time, term):
        # TODO briefly explain how a replica becomes a leader
        self.state = FOLLOWER
        self.leader = leader
        self.current_term = term
        self.next_index = {}
        self.match_index = {}
        self.voted = False
        self.votes = 0
        self.timeout = self.new_timeout()
        self.latest_update = curr_time
        self.latest_rep_update = {}


    def follower_func(self):
        backlog = []
        curr_time = time.time()

        while self.unprocessed_msgs:
            msg = self.unprocessed_msgs.pop(0)

            if msg["type"] in ["get", "put"]:
                if self.leader != "FFFF":
                    response = self.init_msg(msg["src"], "redirect")
                    response["MID"] = msg["MID"]
                    self.client_reponse_queue.append(response)
                else:
                    backlog.append(msg)

            elif msg["type"] == "request_vote":
                # if our/their log is up to date...
                if msg["last_log_index"] >= len(self.log) - 1:
                    # if we are either in the same term & have not yet voted OR
                    # we are in a previous term (indicating new round of elections), send a vote
                    if ((msg["term"] == self.current_term and not self.voted) or
                        msg["term"] > self.current_term):
                        # self.leader = "FFFF"
                        self.current_term = msg["term"]
                        self.voted = True
                        self.latest_update = curr_time
                        self.timeout = self.new_timeout()

                        response = self.init_msg(msg["src"], "vote")
                        response["term"] = self.current_term
                        self.peer_reponse_queue.append(response)
                    # already voted
                    else:
                        pass
                # vote request is for outdated term
                else:
                    pass


            elif msg["type"] == "append_entry":
                # check for consistency
                if (msg["term"] >= self.current_term and
                    msg["prev_log_index"] < len(self.log) and
                    msg["prev_log_term"] == self.log[msg["prev_log_index"]]["term"]):
                    
                    # update follower information accordingly
                    self.leader = msg["leader"]
                    self.current_term = msg["term"]
                    self.voted = False
                    self.latest_update = curr_time

                    # if there are updates for the log
                    if msg["entries"]:
                        # remove any entries not found in leader's log + add new entries
                        self.log = self.log[:msg["prev_log_index"]+1] + msg["entries"]

                        response = self.init_msg(msg["src"], "append_entry_response")
                        response["term"] = self.current_term
                        response["success"] = True
                        response["next_index"] = len(self.log)
                        if msg.get("put_ID"):
                            response["put_ID"] = msg["put_ID"]
                        self.peer_reponse_queue.append(response)

                    if msg["leader_commit"] > self.commit_index:
                        self.commit_index = min(msg["leader_commit"], len(self.log) - 1)

                        while self.commit_index > self.last_applied:
                            self.last_applied += 1
                            last_applied = self.log[self.last_applied]
                            self.kvstore.update({last_applied["key"]: last_applied["value"]})

                # if the new leader has an outdated term, respond with fail (success as False)
                else:
                    response = self.init_msg(msg["src"], "append_entry_response")
                    response["term"] = self.current_term
                    response["success"] = False
                    response["next_index"] = self.commit_index
                    self.peer_reponse_queue.append(response)

        self.unprocessed_msgs = backlog

    def leader_func(self):
        backlog = []
        curr_time = time.time()

        while self.unprocessed_msgs:
            msg = self.unprocessed_msgs.pop(0)

            if msg["type"] == "put":
                # if there's no put that has yet to be committed:
                if not self.staged_put:
                    self.log.append({"client": msg["src"], "term": self.current_term,
                                     "put_ID": msg["MID"], "key": msg["key"], 
                                     "value": msg["value"]})
                    self.staged_put = msg
                    self.quorum.add(self.id)
                    self.num_puts += 1
                else:
                    backlog.append(msg)


            elif msg["type"] == "get":
                val = self.kvstore.get(msg["key"], "")

                response = self.init_msg(msg["src"], "ok")
                response["value"] = val
                response["MID"] = msg["MID"]
                self.client_reponse_queue.append(response)

            elif msg["type"] == "append_entry":
                # if our term is outdated, step down as leader and convert to follower
                # (take all previous, current, and future messages and process them as a follower)
                if msg["term"] > self.current_term:
                    self.follow(msg["leader"], curr_time, msg["term"])
                    self.unprocessed_msgs = backlog + [msg] + self.unprocessed_msgs
                    return self.follower_func()
                # otherwise, make sure the sender know we are still the leader
                # (respond with success False)
                else:
                    response = self.init_msg(msg["src"], "append_entry_response")
                    response["term"] = self.current_term
                    response["success"] = False
                    self.peer_reponse_queue.append(response)
                    

            elif msg["type"] == "request_vote":
                # if our current term is outdated and the other replica's log is further along
                # than our own, step down as leader and convert to follower
                # (take all previous, current, and future messages and process them as a follower)
                if msg["term"] > self.current_term and msg["last_log_index"] >= len(self.log) - 1:
                    self.follow(msg["leader"], curr_time, msg["term"])
                    self.voted = True
                    # response = self.init_msg(msg["src"], "vote")
                    # response["term"] = self.current_term
                    # self.peer_reponse_queue.append(response)
                    self.unprocessed_msgs = backlog + [msg] + self.unprocessed_msgs
                    return self.follower_func()
                # otherwise, reject the vote request
                else:
                    pass

            elif msg["type"] == "append_entry_response":
                # if the append_entry was successful, check the status of the staged put and
                # update accordingly
                if msg["success"]:
                    self.next_index[msg["src"]] = min(msg["next_index"], len(self.log))
                    self.match_index[msg["src"]] = self.next_index[msg["src"]] - 1
                    self.latest_rep_update[msg["src"]]["timeout"] = 0.0025

                    if self.staged_put and msg.get("put_ID") == self.staged_put["MID"]:
                        self.quorum.add(msg["src"])

                        if len(self.quorum) > len(self.others) / 2:
                            self.commit_index = len(self.log) - 1
                            self.staged_put.clear()
                            self.quorum.clear()
                # if our current term is outdated, step down as leader and convert to follower
                # (take all previous and future messages and process them as a follower (no need
                # to take the append_entry_response, since followers have no use for it))
                else:
                    if msg["term"] > self.current_term:
                        # response = self.init_msg(self.staged_put["src"], "redirect")
                        # response["MID"] = self.staged_put["MID"]
                        # self.send(response)
                        self.follow(msg["leader"], curr_time, msg["term"])
                        self.unprocessed_msgs = backlog + self.unprocessed_msgs
                        return self.follower_func()
                    # otherwise, append_entry must have failed due to log inconsistencies, so
                    # update next index and try again
                    else:
                        self.next_index[msg["src"]] = msg["next_index"]

            # TODO: explain
            for n in range(self.commit_index + 1, len(self.log)):
                if (len(list(filter(lambda i: self.match_index[i] >= n, self.match_index)))
                    > len(self.match_index) / 2):
                    if self.log[n]["term"] == self.current_term:
                        self.commit_index = n
                else:
                    break

            # TODO: explain
            while self.commit_index > self.last_applied:
                self.last_applied += 1
                last_app = self.log[self.last_applied]
                self.kvstore.update({last_app["key"]: last_app["value"]})

                response = self.init_msg(last_app["client"], "ok")
                response["MID"] = last_app["put_ID"]
                self.client_reponse_queue.append(response)
        
        self.unprocessed_msgs = backlog

    def candidate_func(self):
        backlog = []
        curr_time = time.time()

        while self.unprocessed_msgs:
            msg = self.unprocessed_msgs.pop(0)

            if msg["type"] in ["get", "put"]:
                backlog.append(msg)

            elif msg["type"] == "append_entry":
                # if our current term is outdated, back out of election and convert to follower
                # (take all previous, current, and future messages and process them as a follower)
                if msg["term"] >= self.current_term:
                    self.follow(msg["leader"], curr_time, msg["term"])
                    self.unprocessed_msgs = backlog + [msg] + self.unprocessed_msgs
                    return self.follower_func()
                # reject the append entry, respond with candidacy?
                else:
                    response = self.init_msg(msg["src"], "append_entry_response")
                    response["success"] = False
                    response["term"] = self.current_term
                    self.peer_reponse_queue.append(response)

            elif msg["type"] == "vote":
                # if the vote is for the correct term (our current term)
                if msg["term"] == self.current_term:
                    self.votes += 1

                    # if we win the election, step up as leader
                    # (take all previous and future messages and process them as a leader (no need
                    # to take the vote, since it's useless as a leader))
                    if self.votes > len(self.others) / 2:
                        self.take_lead()
                        self.unprocessed_msgs = backlog + self.unprocessed_msgs
                        return self.leader_func()
                # otherwise, our term is out of date
                # TODO it works as is? but potentially change it to back out of election,
                # see how that affects things
                elif msg["term"] > self.current_term:
                    pass

            elif msg["type"] == "request_vote":
                # if our current term is outdated, back out of election and convert to follower
                # (take all previous, current, and future messages and process them as a follower)
                if msg["term"] > self.current_term:
                    self.follow(msg["leader"], curr_time, msg["term"])
                    self.unprocessed_msgs = backlog + [msg] + self.unprocessed_msgs
                    return self.follower_func()

        self.unprocessed_msgs = backlog

    def start_election(self):
        # TODO briefly explain election
        self.state = CANDIDATE
        self.current_term += 1
        self.votes = 1

        self.latest_update = time.time()

        request_vote = self.init_msg("FFFF", "request_vote")
        request_vote["term"] = self.current_term
        request_vote["last_log_index"] = len(self.log) - 1
        request_vote["last_log_term"] = self.log[-1]["term"]

        self.peer_reponse_queue.append(request_vote)

    def append_entry(self, rep, entries):
        # TODO briefly explain the fields
        append_entry = self.init_msg(rep, "append_entry")
        append_entry["term"] = self.current_term
        append_entry["prev_log_index"] = self.next_index[rep] - 1
        append_entry["prev_log_term"] = self.log[self.next_index[rep] - 1]["term"]
        append_entry["entries"] = entries[:7]
        append_entry["leader_commit"] = self.commit_index
        append_entry["num_puts"] = self.num_puts
        if self.staged_put:
            append_entry["put_ID"] = self.staged_put["MID"]
        return append_entry

    def run(self):
        while True:
            # respond to clients ASAP
            while self.client_reponse_queue:
                self.send(self.client_reponse_queue.pop(0))

            # respond to peers (other replicas) ASAP
            while self.peer_reponse_queue:
                self.send(self.peer_reponse_queue.pop(0))

            # send updates/heartbeats ASAP
            # TODO explain this a bit more
            if self.state is LEADER:
                for rep in self.others:
                    if (len(self.log) - 1 >= self.next_index[rep]) and (time.time() > self.latest_rep_update[rep]["sent"] + self.latest_rep_update[rep]["timeout"]):
                        self.send(self.append_entry(rep, self.log[self.next_index[rep]:]))
                        self.latest_rep_update[rep]["sent"] = time.time()
                        self.latest_rep_update[rep]["timeout"] = 0.1
                    elif time.time() > self.latest_rep_update[rep]["sent"] + 0.45:
                        self.send(self.append_entry(rep, []))
                        self.latest_rep_update[rep]["sent"] = time.time()

            # receive all messages from the client and from other replicas
            self.receive_all()

            # process messages according to our own state (i.e. our role)
            if self.state == FOLLOWER:
                self.follower_func()
            if self.state == LEADER:
                self.leader_func()
            if self.state == CANDIDATE:
                self.candidate_func()

            # if we're not a leader, we reach election timeout (no message from leader in awhile),
            # and we haven't yet voted in an election currently going on, start a new election
            if (self.state is not LEADER and 
                time.time() > self.latest_update + self.timeout and 
                not self.voted):
                self.start_election()

if __name__ == "__main__":
    parser = argparse.ArgumentParser(description='run a key-value store')
    parser.add_argument('port', type=int, help="Port number to communicate")
    parser.add_argument('id', type=str, help="ID of this replica")
    parser.add_argument('others', metavar='others', type=str, nargs='+', help="IDs of other replicas")
    args = parser.parse_args()
    replica = Replica(args.port, args.id, args.others)
    replica.run()
