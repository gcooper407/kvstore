#!/usr/bin/env python3

import argparse, socket, time, json, select, struct, sys, math, os, random

BROADCAST = "FFFF"

FOLLOWER = "follower"
CANDIDATE = "candidate"
LEADER = "leader"

class Replica:
    def __init__(self, port, id, others):
        self.port = port
        self.id = id
        self.others = others

        self.state = FOLLOWER
        
        self.kvstore = {}
        self.unprocessed_msgs = []
        self.leader = "FFFF"

        self.current_term = 0
        self.voted = False
        self.votes = 0

        self.latest_update = time.time()
        self.timeout = self.new_timeout()

        self.socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        self.socket.bind(('localhost', 0))

        print("Replica %s starting up" % self.id, flush=True)
        hello = { "src": self.id, "dst": BROADCAST, "leader": BROADCAST, "type": "hello" }
        self.send(hello)
        print("Sent hello message: %s" % hello, flush=True)

    def new_timeout(self):
        return random.uniform(0.15,0.3)

    def send(self, message):
        self.socket.sendto(json.dumps(message).encode('utf-8'), ('localhost', self.port))

    def receive_all(self):
        while True:
            msg = self.recv_msg()
            if msg:
                print("Received message '%s'" % (msg,), flush=True)
                self.unprocessed_msgs.append(msg)
            else:
                return
    
    def recv_msg(self):
        ready_for_reading = select.select([self.socket], [], [], 0.000001)[0]
        if self.socket in ready_for_reading:
            raw_msg = self.socket.recv(65535)
            if raw_msg:
                return json.loads(raw_msg.decode('utf-8'))
        return None

    def init_msg(self, dst, type):
        response = {
            "src": self.id,
            "dst": dst,
            "leader": self.leader,
            "type": type
        }
        return response

    def follow(self, leader, curr_time, term):
        self.leader = leader
        self.voted = False
        self.latest_update = curr_time
        self.current_term = term
        self.timeout = self.new_timeout()
        self.votes = 0
        self.state = FOLLOWER

    def follower_func(self):

        backlog = []

        curr_time = time.time()

        while self.unprocessed_msgs:
            msg = self.unprocessed_msgs.pop(0)

            if msg["type"] in ["get", "put"]:
                if self.leader == "FFFF":
                    backlog.append(msg)
                else:
                    response = self.init_msg(msg["src"], "redirect")
                    response["MID"] = msg["MID"]
                    self.send(response)
                    continue

            elif msg["type"] == "request_vote":
                if msg["current_term"] >= self.current_term:
                    if not self.voted:
                        # self.leader = "FFFF"
                        self.current_term = msg["current_term"]
                        response = self.init_msg(msg["src"], "vote")
                        response["current_term"] = self.current_term

                        self.voted = True
                        self.latest_update = curr_time
                        self.timeout = self.new_timeout()

                        self.send(response)
                        continue
                    # already voted, send a vote denial
                    else:
                        pass
                # vote request is for outdated term, send vote denial
                else:
                    pass
                
            
            elif msg["type"] == "append_entry":
                # if the new leader has a up-to-date term, change leadership
                if msg["current_term"] >= self.current_term:
                    self.leader = msg["leader"]
                    self.current_term = msg["current_term"]
                    self.voted = False
                    self.latest_update = curr_time
                # if the new leader has an outdated term, reject the append entry and
                # inform it of the proper leader
                else:
                    pass
                

        self.unprocessed_msgs = backlog



    def leader_func(self):
        backlog = []
        curr_time = time.time()
            
        while self.unprocessed_msgs:
            msg = self.unprocessed_msgs.pop(0)

            if msg["type"] == "put":
                self.kvstore[msg["key"]] = msg["value"]
                response = self.init_msg(msg["src"], "ok")
                response["MID"] = msg["MID"]
                self.send(response)
                continue

            elif msg["type"] == "get":
                val = self.kvstore.get(msg["key"])

                if val:
                    response = self.init_msg(msg["src"], "ok")
                    response["value"] = val
                else:
                    response = self.init_msg(msg["src"], "fail")

                response["MID"] = msg["MID"]
                self.send(response)
                continue

            elif msg["type"] == "append_entry":
                if msg["current_term"] > self.current_term:
                    self.follow(msg["leader"], curr_time, msg["current_term"])
                # else, make sure everyone knows we are still the leader
                # NOTE: maybe change later depending on efficiency
                else:
                    append_entry = self.init_msg("FFFF", "append_entry")
                    append_entry["current_term"] = self.current_term
                    self.send(append_entry)


            elif msg["type"] == "request_vote":
                # if our current term is outdated, step down as leader
                if msg["current_term"] > self.current_term:
                    pass
                # otherwise, reject the vote request
                else:
                    pass

    
    def candidate_func(self):
        curr_time = time.time()
            
        while self.unprocessed_msgs:
            msg = self.unprocessed_msgs.pop(0)

            if msg["type"] == "append_entry":
                # if our term is outdated, back out of election and follow
                if msg["current_term"] >= self.current_term:
                    self.follow(msg["leader"], curr_time, msg["current_term"])
                # reject the append entry, respond with candidacy?
                else:
                    pass

            
            elif msg["type"] == "vote":
                if msg["current_term"] == self.current_term:
                    self.votes += 1
                    
                    if self.votes >= math.ceil(len(self.others)/2):
                        self.leader = self.id
                        append_entry = self.init_msg("FFFF", "append_entry")
                        append_entry["current_term"] = self.current_term
                        self.send(append_entry)
                        self.state = LEADER
                        continue
                # back out of election
                if msg["current_term"] > self.current_term:
                    pass

            # depending on current_term, either reject vote or step down and vote
            elif msg["type"] == "request_vote":
                pass


    def start_election(self):
        self.state = CANDIDATE
        self.current_term += 1
        self.votes += 1

        self.latest_update = time.time()

        request_vote = self.init_msg("FFFF", "request_vote")
        request_vote["current_term"] = self.current_term

        self.send(request_vote)


    def run(self):
        while True:

            if self.state is LEADER and time.time() > self.latest_update + 0.1:
                heartbeat = self.init_msg("FFFF", "append_entry")
                heartbeat["current_term"] = self.current_term
                self.send(heartbeat)
                self.latest_update = time.time()

            self.receive_all()

            if self.state == FOLLOWER:
                self.follower_func()
            if self.state == LEADER:
                self.leader_func()
            if self.state == CANDIDATE:
                self.candidate_func()

            if self.state is not LEADER and time.time() > self.latest_update + self.timeout:
                self.start_election()


if __name__ == "__main__":
    parser = argparse.ArgumentParser(description='run a key-value store')
    parser.add_argument('port', type=int, help="Port number to communicate")
    parser.add_argument('id', type=str, help="ID of this replica")
    parser.add_argument('others', metavar='others', type=str, nargs='+', help="IDs of other replicas")
    args = parser.parse_args()
    replica = Replica(args.port, args.id, args.others)
    replica.run()
